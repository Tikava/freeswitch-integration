export interface AsyncReadStream<TOutput> {
  read(signal?: AbortSignal): AsyncIterable<TOutput>;
  transform(): AsyncTransform<TOutput>;
}

export interface AsyncWriteStream<TInput> {
  write(input: TInput): Promise<void>;
}

export interface AsyncStream<TOutput, TInput = TOutput>
  extends AsyncReadStream<TOutput>,
    AsyncWriteStream<TInput> {}

export type AsyncTransformPipeConfig = {
  signal?: AbortSignal;
  await?: boolean;
};

export type AsyncBufferWaitMode =
  | "insert"
  | "done"
  | {
      when: "interval";
      interval: number;
    }
  | {
      when: "capacity";
      capacity: number;
    };

export type AsyncBufferClearMode =
  | "none"
  | "all-read"
  | "single-read"
  | {
      when: "amount";
      amount: number;
      keep: number;
    };
export interface AsyncBufferConfig {
  signal?: AbortSignal;
  onReader?: (start: () => Promise<void>) => void;
  onRegionComplete?: (ref: {}, startIndex: number, endIndex: number) => void;
  wait?: AsyncBufferWaitMode;
  clear?: AsyncBufferClearMode;
}

function bufferAsyncIterable<T>(
  iterable: AsyncIterable<T>,
  config?: AsyncBufferConfig
): (ref?: {}) => AsyncIterable<T> {
  const buffer: T[] = [];
  const resolvers: (() => void)[] = [];

  let complete = false;
  let clearOffset = 0;
  let previousResolveCapacity = 0;

  const waitMode = config?.wait ?? "insert";
  const clearMode = config?.clear ?? "none";

  const readerOffsets = new Map<{}, number>();

  const regionComplete = (ref: {}, startIndex: number, endIndex: number) => {
    if (config?.onRegionComplete) {
      config.onRegionComplete(ref, startIndex, endIndex);
    }

    if (clearMode === "all-read") {
      let minIndex = endIndex;

      for (const offset of readerOffsets.values()) {
        if (offset < minIndex) {
          minIndex = offset;
        }
      }

      clearOffset += buffer.splice(0, minIndex - clearOffset).length;
    }

    if (clearMode === "single-read") {
      clearOffset += buffer.splice(0, endIndex - clearOffset).length;
    }
  };

  const startReader = async () => {
    let interval: any | undefined = undefined;
    if (
      typeof waitMode === "object" &&
      "when" in waitMode &&
      waitMode.when === "interval"
    ) {
      interval = setInterval(() => {
        if (resolvers.length > 0) {
          for (const resolve of resolvers) {
            resolve();
          }
          resolvers.splice(0, resolvers.length);
        }
      }, waitMode.interval);
    }

    try {
      for await (const item of iterable) {
        if (config?.signal?.aborted) {
          break;
        }

        buffer.push(item);

        if (
          typeof clearMode === "object" &&
          "when" in clearMode &&
          clearMode.when === "amount"
        ) {
          if (buffer.length >= clearMode.amount) {
            const end = buffer.length - clearMode.keep;
            clearOffset += buffer.splice(0, Math.max(end, 0)).length;
          }
        }

        if (resolvers.length > 0 && waitMode === "insert") {
          for (const resolve of resolvers) {
            resolve();
          }
          resolvers.splice(0, resolvers.length);
        }

        if (
          typeof waitMode === "object" &&
          "when" in waitMode &&
          waitMode.when === "capacity"
        ) {
          if (
            buffer.length + clearOffset >=
            waitMode.capacity + previousResolveCapacity
          ) {
            if (resolvers.length) {
              for (const resolve of resolvers) {
                resolve();
              }
              resolvers.splice(0, resolvers.length);
            }
            previousResolveCapacity = buffer.length + clearOffset;
          }
        }
      }

      if (resolvers.length && waitMode === "done") {
        for (const resolve of resolvers) {
          resolve();
        }
        resolvers.splice(0, resolvers.length);
      }
    } finally {
      complete = true;
      if (interval) {
        clearInterval(interval);
      }
    }
  };

  if (config?.onReader) {
    config.onReader(() => {
      if (complete || config?.signal?.aborted) {
        return Promise.resolve();
      }
      return startReader();
    });
  } else {
    if (config?.signal?.aborted) {
      return async function* () {
        config?.signal?.throwIfAborted();
      };
    }
    startReader();
  }

  return async function* (ref: {} = {}) {
    config?.signal?.throwIfAborted();

    readerOffsets.set(ref, 0);
    try {
      let endIndex = 0;

      while (!complete || endIndex < buffer.length + clearOffset) {
        if (config?.signal?.aborted) {
          break;
        }

        if (endIndex === buffer.length + clearOffset) {
          await new Promise<void>((resolver) => resolvers.push(resolver));
          continue;
        }

        const startIndex = Math.max(endIndex - clearOffset, 0);
        endIndex = buffer.length + clearOffset;
        readerOffsets.set(ref, endIndex);

        yield* buffer.slice(startIndex);
        regionComplete(ref, startIndex, endIndex);
      }
    } catch {
      readerOffsets.delete(ref);
    }
  };
}

function getAsyncIterableFactoryReadStream<T>(
  iterate: () => AsyncIterable<T>
): AsyncReadStream<T> {
  return {
    async *read(signal?: AbortSignal) {
      for await (const it of iterate()) {
        if (signal?.aborted) {
          break;
        }
        yield it;
      }
    },
    transform() {
      return new AsyncTransform<T>(this);
    },
  };
}

export type TransformFunction<TBase, T> = (
  stream: AsyncReadStream<TBase>
) => AsyncReadStream<T>;

type AsyncReadStreamLike<T> =
  | Iterable<T>
  | AsyncIterable<T>
  | AsyncReadStream<T>;

export class AsyncTransform<TOutput>
  implements AsyncReadStream<TOutput>, AsyncIterable<TOutput>
{
  #baseStream: AsyncReadStream<TOutput>;
  constructor(stream: AsyncReadStream<TOutput>) {
    this.#baseStream = stream;
  }

  transform(): AsyncTransform<TOutput> {
    return this;
  }

  apply<T>(transformFunction: TransformFunction<TOutput, T>) {
    return transformFunction(this).transform();
  }

  [Symbol.asyncIterator](abort?: AbortSignal): AsyncIterator<TOutput> {
    return this.#baseStream.read(abort)[Symbol.asyncIterator]();
  }

  read(signal?: AbortSignal): AsyncIterable<TOutput> {
    return this.#baseStream.read(signal);
  }

  stream(): AsyncReadStream<TOutput> {
    return this.#baseStream;
  }

  static concat<TOutput>(
    ...streams: AsyncReadStream<TOutput>[]
  ): AsyncTransform<TOutput> {
    return new AsyncTransform<TOutput>({
      async *read(signal) {
        for (const stream of streams) {
          yield* stream.read(signal);
        }
      },
      transform() {
        return new AsyncTransform(this);
      },
    });
  }

  concat(...streams: AsyncReadStream<TOutput>[]) {
    return AsyncTransform.concat(this, ...streams);
  }

  buffer(config?: AsyncBufferConfig): AsyncTransform<TOutput> {
    return new AsyncTransform<TOutput>(
      getAsyncIterableFactoryReadStream(bufferAsyncIterable(this, config))
    );
  }

  with(signal: AbortSignal): AsyncTransform<TOutput> {
    const baseStream = this.#baseStream;
    return new AsyncTransform<TOutput>({
      read(previousSignal) {
        const controller = new AbortController();

        const abortHandler = (abortEvent: Event) => {
          controller.abort(abortEvent);
          signal.removeEventListener("abort", abortHandler);
          previousSignal?.removeEventListener("abort", abortHandler);
        };

        signal.addEventListener("abort", abortHandler);
        previousSignal?.addEventListener("abort", abortHandler);

        return baseStream.read(controller.signal);
      },
      transform() {
        return new AsyncTransform<TOutput>(this);
      },
    });
  }

  map<T>(fn: (item: TOutput) => Promise<T> | T) {
    const baseStream = this.#baseStream;
    return new AsyncTransform<T>({
      async *read(signal) {
        for await (const item of baseStream.read(signal)) {
          yield await fn(item);
        }
      },
      transform() {
        return new AsyncTransform(this);
      },
    });
  }

  async forEach(
    fn: (item: TOutput) => Promise<void> | void,
    signal?: AbortSignal
  ) {
    for await (const item of this.#baseStream.read(signal)) {
      await fn(item);
    }
  }

  async toArray(signal?: AbortSignal) {
    const array: TOutput[] = [];
    for await (const item of this.#baseStream.read(signal)) {
      array.push(item);
    }
    return array;
  }

  async first(
    condition: (item: TOutput) => Promise<boolean> | boolean,
    signal?: AbortSignal
  ): Promise<TOutput | undefined> {
    for await (const item of this.#baseStream.read(signal)) {
      if (await condition(item)) {
        return item;
      }
    }
  }

  async pipe(
    writeStream: AsyncWriteStream<TOutput>,
    config?: AsyncTransformPipeConfig
  ) {
    for await (const item of this.#baseStream.read(config?.signal)) {
      if (config?.await === false) {
        void writeStream.write(item);
      } else {
        await writeStream.write(item);
      }
    }
  }

  filter(condition: (item: TOutput) => Promise<boolean> | boolean) {
    const baseStream = this.#baseStream;
    return new AsyncTransform<TOutput>({
      async *read(signal) {
        for await (const item of baseStream.read(signal)) {
          if (await condition(item)) {
            yield item;
          }
        }
      },
      transform() {
        return new AsyncTransform(this);
      },
    });
  }

  static from<T>(
    source: AsyncReadStreamLike<T> | Promise<AsyncReadStreamLike<T>>
  ): AsyncTransform<T> {
    return new AsyncTransform<T>({
      async *read(signal) {
        const result = await source;
        if ("read" in result) {
          yield* result.read(signal);
        } else {
          yield* result;
        }
      },
      transform() {
        return new AsyncTransform(this);
      },
    });
  }

  flatMap<T>(
    fn: (
      item: TOutput
    ) => AsyncReadStreamLike<T> | Promise<AsyncReadStreamLike<T>>
  ) {
    const baseStream = this.#baseStream;
    return new AsyncTransform<T>({
      async *read(signal) {
        for await (const item of baseStream.read(signal)) {
          const result = await fn(item);
          if ("read" in result) {
            yield* result.read(signal);
          } else {
            yield* result;
          }
        }
      },
      transform() {
        return new AsyncTransform(this);
      },
    });
  }
}
