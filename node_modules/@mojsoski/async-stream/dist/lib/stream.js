"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncTransform = void 0;
function bufferAsyncIterable(iterable, config) {
    const buffer = [];
    const resolvers = [];
    let complete = false;
    let clearOffset = 0;
    let previousResolveCapacity = 0;
    const waitMode = config?.wait ?? "insert";
    const clearMode = config?.clear ?? "none";
    const readerOffsets = new Map();
    const regionComplete = (ref, startIndex, endIndex) => {
        if (config?.onRegionComplete) {
            config.onRegionComplete(ref, startIndex, endIndex);
        }
        if (clearMode === "all-read") {
            let minIndex = endIndex;
            for (const offset of readerOffsets.values()) {
                if (offset < minIndex) {
                    minIndex = offset;
                }
            }
            clearOffset += buffer.splice(0, minIndex - clearOffset).length;
        }
        if (clearMode === "single-read") {
            clearOffset += buffer.splice(0, endIndex - clearOffset).length;
        }
    };
    const startReader = async () => {
        let interval = undefined;
        if (typeof waitMode === "object" &&
            "when" in waitMode &&
            waitMode.when === "interval") {
            interval = setInterval(() => {
                if (resolvers.length > 0) {
                    for (const resolve of resolvers) {
                        resolve();
                    }
                    resolvers.splice(0, resolvers.length);
                }
            }, waitMode.interval);
        }
        try {
            for await (const item of iterable) {
                if (config?.signal?.aborted) {
                    break;
                }
                buffer.push(item);
                if (typeof clearMode === "object" &&
                    "when" in clearMode &&
                    clearMode.when === "amount") {
                    if (buffer.length >= clearMode.amount) {
                        const end = buffer.length - clearMode.keep;
                        clearOffset += buffer.splice(0, Math.max(end, 0)).length;
                    }
                }
                if (resolvers.length > 0 && waitMode === "insert") {
                    for (const resolve of resolvers) {
                        resolve();
                    }
                    resolvers.splice(0, resolvers.length);
                }
                if (typeof waitMode === "object" &&
                    "when" in waitMode &&
                    waitMode.when === "capacity") {
                    if (buffer.length + clearOffset >=
                        waitMode.capacity + previousResolveCapacity) {
                        if (resolvers.length) {
                            for (const resolve of resolvers) {
                                resolve();
                            }
                            resolvers.splice(0, resolvers.length);
                        }
                        previousResolveCapacity = buffer.length + clearOffset;
                    }
                }
            }
            if (resolvers.length && waitMode === "done") {
                for (const resolve of resolvers) {
                    resolve();
                }
                resolvers.splice(0, resolvers.length);
            }
        }
        finally {
            complete = true;
            if (interval) {
                clearInterval(interval);
            }
        }
    };
    if (config?.onReader) {
        config.onReader(() => {
            if (complete || config?.signal?.aborted) {
                return Promise.resolve();
            }
            return startReader();
        });
    }
    else {
        if (config?.signal?.aborted) {
            return async function* () {
                config?.signal?.throwIfAborted();
            };
        }
        startReader();
    }
    return async function* (ref = {}) {
        config?.signal?.throwIfAborted();
        readerOffsets.set(ref, 0);
        try {
            let endIndex = 0;
            while (!complete || endIndex < buffer.length + clearOffset) {
                if (config?.signal?.aborted) {
                    break;
                }
                if (endIndex === buffer.length + clearOffset) {
                    await new Promise((resolver) => resolvers.push(resolver));
                    continue;
                }
                const startIndex = Math.max(endIndex - clearOffset, 0);
                endIndex = buffer.length + clearOffset;
                readerOffsets.set(ref, endIndex);
                yield* buffer.slice(startIndex);
                regionComplete(ref, startIndex, endIndex);
            }
        }
        catch {
            readerOffsets.delete(ref);
        }
    };
}
function getAsyncIterableFactoryReadStream(iterate) {
    return {
        async *read(signal) {
            for await (const it of iterate()) {
                if (signal?.aborted) {
                    break;
                }
                yield it;
            }
        },
        transform() {
            return new AsyncTransform(this);
        },
    };
}
class AsyncTransform {
    #baseStream;
    constructor(stream) {
        this.#baseStream = stream;
    }
    transform() {
        return this;
    }
    apply(transformFunction) {
        return transformFunction(this).transform();
    }
    [Symbol.asyncIterator](abort) {
        return this.#baseStream.read(abort)[Symbol.asyncIterator]();
    }
    read(signal) {
        return this.#baseStream.read(signal);
    }
    stream() {
        return this.#baseStream;
    }
    static concat(...streams) {
        return new AsyncTransform({
            async *read(signal) {
                for (const stream of streams) {
                    yield* stream.read(signal);
                }
            },
            transform() {
                return new AsyncTransform(this);
            },
        });
    }
    concat(...streams) {
        return AsyncTransform.concat(this, ...streams);
    }
    buffer(config) {
        return new AsyncTransform(getAsyncIterableFactoryReadStream(bufferAsyncIterable(this, config)));
    }
    with(signal) {
        const baseStream = this.#baseStream;
        return new AsyncTransform({
            read(previousSignal) {
                const controller = new AbortController();
                const abortHandler = (abortEvent) => {
                    controller.abort(abortEvent);
                    signal.removeEventListener("abort", abortHandler);
                    previousSignal?.removeEventListener("abort", abortHandler);
                };
                signal.addEventListener("abort", abortHandler);
                previousSignal?.addEventListener("abort", abortHandler);
                return baseStream.read(controller.signal);
            },
            transform() {
                return new AsyncTransform(this);
            },
        });
    }
    map(fn) {
        const baseStream = this.#baseStream;
        return new AsyncTransform({
            async *read(signal) {
                for await (const item of baseStream.read(signal)) {
                    yield await fn(item);
                }
            },
            transform() {
                return new AsyncTransform(this);
            },
        });
    }
    async forEach(fn, signal) {
        for await (const item of this.#baseStream.read(signal)) {
            await fn(item);
        }
    }
    async toArray(signal) {
        const array = [];
        for await (const item of this.#baseStream.read(signal)) {
            array.push(item);
        }
        return array;
    }
    async first(condition, signal) {
        for await (const item of this.#baseStream.read(signal)) {
            if (await condition(item)) {
                return item;
            }
        }
    }
    async pipe(writeStream, config) {
        for await (const item of this.#baseStream.read(config?.signal)) {
            if (config?.await === false) {
                void writeStream.write(item);
            }
            else {
                await writeStream.write(item);
            }
        }
    }
    filter(condition) {
        const baseStream = this.#baseStream;
        return new AsyncTransform({
            async *read(signal) {
                for await (const item of baseStream.read(signal)) {
                    if (await condition(item)) {
                        yield item;
                    }
                }
            },
            transform() {
                return new AsyncTransform(this);
            },
        });
    }
    static from(source) {
        return new AsyncTransform({
            async *read(signal) {
                const result = await source;
                if ("read" in result) {
                    yield* result.read(signal);
                }
                else {
                    yield* result;
                }
            },
            transform() {
                return new AsyncTransform(this);
            },
        });
    }
    flatMap(fn) {
        const baseStream = this.#baseStream;
        return new AsyncTransform({
            async *read(signal) {
                for await (const item of baseStream.read(signal)) {
                    const result = await fn(item);
                    if ("read" in result) {
                        yield* result.read(signal);
                    }
                    else {
                        yield* result;
                    }
                }
            },
            transform() {
                return new AsyncTransform(this);
            },
        });
    }
}
exports.AsyncTransform = AsyncTransform;
//# sourceMappingURL=stream.js.map