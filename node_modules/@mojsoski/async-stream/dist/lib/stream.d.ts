export interface AsyncReadStream<TOutput> {
    read(signal?: AbortSignal): AsyncIterable<TOutput>;
    transform(): AsyncTransform<TOutput>;
}
export interface AsyncWriteStream<TInput> {
    write(input: TInput): Promise<void>;
}
export interface AsyncStream<TOutput, TInput = TOutput> extends AsyncReadStream<TOutput>, AsyncWriteStream<TInput> {
}
export type AsyncTransformPipeConfig = {
    signal?: AbortSignal;
    await?: boolean;
};
export type AsyncBufferWaitMode = "insert" | "done" | {
    when: "interval";
    interval: number;
} | {
    when: "capacity";
    capacity: number;
};
export type AsyncBufferClearMode = "none" | "all-read" | "single-read" | {
    when: "amount";
    amount: number;
    keep: number;
};
export interface AsyncBufferConfig {
    signal?: AbortSignal;
    onReader?: (start: () => Promise<void>) => void;
    onRegionComplete?: (ref: {}, startIndex: number, endIndex: number) => void;
    wait?: AsyncBufferWaitMode;
    clear?: AsyncBufferClearMode;
}
export type TransformFunction<TBase, T> = (stream: AsyncReadStream<TBase>) => AsyncReadStream<T>;
type AsyncReadStreamLike<T> = Iterable<T> | AsyncIterable<T> | AsyncReadStream<T>;
export declare class AsyncTransform<TOutput> implements AsyncReadStream<TOutput>, AsyncIterable<TOutput> {
    #private;
    constructor(stream: AsyncReadStream<TOutput>);
    transform(): AsyncTransform<TOutput>;
    apply<T>(transformFunction: TransformFunction<TOutput, T>): AsyncTransform<T>;
    [Symbol.asyncIterator](abort?: AbortSignal): AsyncIterator<TOutput>;
    read(signal?: AbortSignal): AsyncIterable<TOutput>;
    stream(): AsyncReadStream<TOutput>;
    static concat<TOutput>(...streams: AsyncReadStream<TOutput>[]): AsyncTransform<TOutput>;
    concat(...streams: AsyncReadStream<TOutput>[]): AsyncTransform<TOutput>;
    buffer(config?: AsyncBufferConfig): AsyncTransform<TOutput>;
    with(signal: AbortSignal): AsyncTransform<TOutput>;
    map<T>(fn: (item: TOutput) => Promise<T> | T): AsyncTransform<T>;
    forEach(fn: (item: TOutput) => Promise<void> | void, signal?: AbortSignal): Promise<void>;
    toArray(signal?: AbortSignal): Promise<TOutput[]>;
    first(condition: (item: TOutput) => Promise<boolean> | boolean, signal?: AbortSignal): Promise<TOutput | undefined>;
    pipe(writeStream: AsyncWriteStream<TOutput>, config?: AsyncTransformPipeConfig): Promise<void>;
    filter(condition: (item: TOutput) => Promise<boolean> | boolean): AsyncTransform<TOutput>;
    static from<T>(source: AsyncReadStreamLike<T> | Promise<AsyncReadStreamLike<T>>): AsyncTransform<T>;
    flatMap<T>(fn: (item: TOutput) => AsyncReadStreamLike<T> | Promise<AsyncReadStreamLike<T>>): AsyncTransform<T>;
}
export {};
